worker_processes 1; # nginx OS level processes, usually 1 per CPU core
events { worker_connections 4096; } # maximum parallel TCP connections per worker
http {
    client_max_body_size 4g; # max size of request body
    proxy_request_buffering off; # do not store the file on the file system (passthrough mode)

    proxy_connect_timeout 60s; # Time to establish connection to upstream server
    proxy_send_timeout 60m; # Time to send request to upstream server (for large uploads)
    proxy_read_timeout 60m; # Time to receive response from upstream server (for long processing)

    client_body_timeout 60m; # Time to receive complete request body from client
    client_header_timeout 60m; # Time to receive complete request headers from client

    send_timeout 60m; # Time to send response back to client (for large downloads)

    sendfile on; # Enables zero-copy file transfer to improve performance, only works with static files

    upstream backend {
        server 127.0.0.1:8081;
        keepalive 64;            # Pool size
        keepalive_timeout 60s;   # Match your other timeouts
    }

    # Determine if user is authenticated (any Authorization header present)
    map $http_authorization $auth_type {
        ""      "none";         # non-authenticated
        default "authenticated";
    }

    # Create unique identifier for rate limiting based on full auth header
    map $http_authorization $rate_limit_key {
        ~^$ $http_x_cf_true_client_ip; # unauthenticated requests use remote IP, during health check header not sent (grouped by empty)
        default $http_authorization;   # authenticated requests use auth header
    }

    # Extract path from request URI for path checking
    map $request_uri $request_path {
        ~^([^?]*) $1;
        default $uri;
    }

    # Check if path is allowed (returns "allowed" or "blocked")
    map $request_path $path_allowed {
        # Allow exact paths and any subpaths (with or without trailing slash)
        ~^/api/v1/csrf-token(/.*)?$ "allowed";
        ~^/api/v1/spaces/[^/]+/files(/.*)?$ "allowed";
        ~^/api/v1/info(/.*)?$ "allowed";
        ~^/api/v1/spaces/[^/]+/mtas(/.*)?$ "allowed";
        ~^/api/v1/spaces/[^/]+/operations(/.*)?$ "allowed";
        ~^/api/v2/spaces/[^/]+/mtas(/.*)?$ "allowed";
        ~^/public(/.*)?$ "allowed";
        ~^/rest(/.*)?$ "allowed";

        default "blocked";
    }

    # Identify the type of request based on method
    map "$request_method" $request_type {
        # Non-changing requests (GET, HEAD, OPTIONS)
        ~^(?!(POST|PUT|DELETE|PATCH)) "non-changing";
        # All other changing requests (POST, PUT, DELETE, PATCH)
        default "changing";
    }

    # Identify specific endpoints for targeted rate limiting
    map "$request_method:$request_path" $endpoint_type {
        # Operations API endpoints with different rate limits (POST only)
        ~^POST:/api/v1/spaces/[^/]+/files$ "files";                    # 600req/m
        ~^POST:/api/v1/spaces/[^/]+/files/async$ "files_async";        # 150req/m
        ~^POST:/api/v1/spaces/[^/]+/operations$ "operations";          # 150req/m
        ~^POST:/api/v1/spaces/[^/]+/operations/[^/]+$ "operations_id"; # 150req/m
    }

    # Custom log format
    log_format cloudfoundry 'Request: "$request", Status: $status, Request type: "$request_type", User IP: $http_x_cf_true_client_ip, Auth Type: $auth_type, URI: $uri, Request URI: $request_uri, Request path: $request_path, Path Allowed: $path_allowed, Endpoint Type: $endpoint_type, Upstream Response Time: $upstream_response_time, Total Request Time: $request_time';

    access_log /dev/stdout cloudfoundry;

    # Enhanced error logging for nginx crashes and detailed debugging
    error_log /dev/stderr info;  # 'info' level captures more details including:
                                # - Worker process crashes
                                # - Upstream connection failures
                                # - Memory/resource issues
                                # - Configuration reload problems

    limit_req_status 429; # Set status code for rate limiting errors

    # Rate limiting zones - different rates for authenticated vs unauthenticated
    limit_req_zone $rate_limit_key zone=changing_authenticated_limit:10m rate=300r/m;
    limit_req_zone $rate_limit_key zone=non_changing_authenticated_limit:10m rate=500r/m;

    # Unauthenticated requests use the true client IP for rate limiting
    limit_req_zone $http_x_cf_true_client_ip zone=unauthenticated_limit:10m rate=100r/m;

    # Existing specific rate limiting zones for POST endpoints
    limit_req_zone $rate_limit_key zone=post_files:10m rate=600r/m;           # /files
    limit_req_zone $rate_limit_key zone=post_files_async:10m rate=150r/m;     # /files/async
    limit_req_zone $rate_limit_key zone=post_operations:10m rate=150r/m;      # /operations
    limit_req_zone $rate_limit_key zone=post_operations_id:10m rate=150r/m;   # /operations/{id}

    server {
        listen 8082;
        server_name localhost;

        # Main proxy location with path validation and conditional rate limiting
        location / {
            # Check if path is allowed - return 404 if blocked
            if ($path_allowed = "blocked") {
                return 404 '{"error":"Not found","message":"The requested endpoint was not found"}';
            }

            if ($auth_type = "none") {
                rewrite ^(.*)$ /internal/unauthenticated$1 last;
            }
            if ($request_type = "non-changing") {
                rewrite ^(.*)$ /internal/non_changing_authenticated_limit$1 last;
            }

            # Route to Operations API endpoints
            if ($endpoint_type = "files") {
                rewrite ^(.*)$ /internal/post_files$1 last;
            }
            if ($endpoint_type = "files_async") {
                rewrite ^(.*)$ /internal/post_files_async$1 last;
            }
            if ($endpoint_type = "operations") {
                rewrite ^(.*)$ /internal/post_operations$1 last;
            }
            if ($endpoint_type = "operations_id") {
                rewrite ^(.*)$ /internal/post_operations_id$1 last;
            }

            if ($request_type = "changing") {
                rewrite ^(.*)$ /internal/changing_authenticated_limit$1 last;
            }
        }

        # Internal location for all unauthenticated requests
        location /internal/unauthenticated {
            internal; # Only accessible via nginx rewrites, blocks direct external requests
            limit_req zone=unauthenticated_limit burst=100 nodelay;

            proxy_pass http://127.0.0.1:8081$request_uri;
            proxy_set_header Host $host;
            proxy_pass_request_headers on;
            proxy_http_version 1.1;        # Use HTTP/1.1 (supports keepalive)
            proxy_set_header Connection ""; # Clear Connection header (enable keepalive)
        }

        # Internal location for changing authenticated requests
        location /internal/changing_authenticated_limit {
            internal; # Only accessible via nginx rewrites, blocks direct external requests
            limit_req zone=changing_authenticated_limit burst=500 nodelay;

            proxy_pass http://127.0.0.1:8081$request_uri;
            proxy_set_header Host $host;
            proxy_pass_request_headers on;
            proxy_http_version 1.1;        # Use HTTP/1.1 (supports keepalive)
            proxy_set_header Connection ""; # Clear Connection header (enable keepalive)
        }

        # Internal location for non-changing authenticated requests
        location /internal/non_changing_authenticated_limit {
            internal; # Only accessible via nginx rewrites, blocks direct external requests
            limit_req zone=non_changing_authenticated_limit burst=500 nodelay;

            proxy_pass http://127.0.0.1:8081$request_uri;
            proxy_set_header Host $host;
            proxy_pass_request_headers on;
            proxy_http_version 1.1;        # Use HTTP/1.1 (supports keepalive)
            proxy_set_header Connection ""; # Clear Connection header (enable keepalive)
        }

        # Existing specific endpoint rate limiting locations
        # /api/v1/spaces/{spaceGuid}/files - 600req/m (POST only)
        location /internal/post_files {
            internal; # Only accessible via nginx rewrites, blocks direct external requests
            limit_req zone=post_files burst=600 nodelay;

            proxy_pass http://127.0.0.1:8081$request_uri;
            proxy_set_header Host $host;
            proxy_pass_request_headers on;
            proxy_http_version 1.1;        # Use HTTP/1.1 (supports keepalive)
            proxy_set_header Connection ""; # Clear Connection header (enable keepalive)
        }

        # /api/v1/spaces/{spaceGuid}/files/async - 150req/m (POST only)
        location /internal/post_files_async {
            internal; # Only accessible via nginx rewrites, blocks direct external requests
            limit_req zone=post_files_async burst=150 nodelay;

            proxy_pass http://127.0.0.1:8081$request_uri;
            proxy_set_header Host $host;
            proxy_pass_request_headers on;
            proxy_http_version 1.1;        # Use HTTP/1.1 (supports keepalive)
            proxy_set_header Connection ""; # Clear Connection header (enable keepalive)
        }

        # /api/v1/spaces/{spaceGuid}/operations - 150req/m (POST only)
        location /internal/post_operations {
            internal; # Only accessible via nginx rewrites, blocks direct external requests
            limit_req zone=post_operations burst=150 nodelay;

            proxy_pass http://127.0.0.1:8081$request_uri;
            proxy_set_header Host $host;
            proxy_pass_request_headers on;
            proxy_http_version 1.1;        # Use HTTP/1.1 (supports keepalive)
            proxy_set_header Connection ""; # Clear Connection header (enable keepalive)
        }

        # /api/v1/spaces/{spaceGuid}/operations/{operationId} - 150req/m (POST only)
        location /internal/post_operations_id {
            internal; # Only accessible via nginx rewrites, blocks direct external requests
            limit_req zone=post_operations_id burst=150 nodelay;

            proxy_pass http://127.0.0.1:8081$request_uri;
            proxy_set_header Host $host;
            proxy_pass_request_headers on;
            proxy_http_version 1.1;        # Use HTTP/1.1 (supports keepalive)
            proxy_set_header Connection ""; # Clear Connection header (enable keepalive)
        }

        # Rate limit error response
        error_page 429 = @rate_limit_error;
        location @rate_limit_error {
            add_header Content-Type application/json always;
            return 429 '{"error":"Rate limit exceeded","message":"Too many requests"}';
        }
    }
}